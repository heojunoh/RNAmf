% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ALC.R
\name{ALC_RNAmf}
\alias{ALC_RNAmf}
\title{find the next point by ALC criterion}
\usage{
ALC_RNAmf(Xref = NULL, Xcand = NULL, fit, mc.sample = 100,
cost = NULL, optim = TRUE, parallel = FALSE, ncore = 1)
}
\arguments{
\item{Xref}{vector or matrix of reference location to approximate the integral of ALC. If \code{Xref=NULL}, \eqn{100 \times d} points are generated by Latin hypercube design. Default is \code{NULL}.}

\item{Xcand}{vector or matrix of candidate set which could be added into the current design only when \code{optim=FALSE}. \code{Xcand} is the set of the points where ALC criterion is evaluated. If \code{Xcand=NULL}, \code{Xref} is used. Default is \code{NULL}. See details.}

\item{fit}{object of class \code{RNAmf}.}

\item{mc.sample}{a number of mc samples generated for the imputation through MC approximation. Default is \code{100}.}

\item{cost}{vector of the costs for each level of fidelity. If \code{cost=NULL}, total costs at all levels would be 1. \code{cost} is encouraged to have a ascending order of positive value. Default is \code{NULL}.}

\item{optim}{logical indicating whether to optimize AL criterion by \code{optim}'s gradient-based \code{L-BFGS-B} method. If \code{optim=TRUE}, \eqn{5 \times d} starting points are generated by Latin hypercube design for optimization. If \code{optim=FALSE}, AL criterion is optimized on the \code{Xcand}. Default is \code{TRUE}.}

\item{parallel}{logical indicating whether to compute the AL criterion in parallel or not. If \code{parallel=TRUE}, parallel computation is utilized. Default is \code{FALSE}.}

\item{ncore}{a number of core for parallel. It is only used if \code{parallel=TRUE}. Default is 1.}
}
\value{
\itemize{
  \item \code{ALC}: list of ALC criterion integrated on \code{Xref} when each data point on \code{Xcand} is added at each level \eqn{l} if \code{optim=FALSE}. If \code{optim=TRUE}, \code{ALC} returns \code{NULL}.
  \item \code{cost}: a copy of \code{cost}.
  \item \code{Xcand}: a copy of \code{Xcand}.
  \item \code{chosen}: list of chosen level and point.
  \item \code{time}: a scalar of the time for the computation.
}
}
\description{
The function acquires the new point by the Active learning Cohn (ALC) criterion.
It calculates the ALC criterion
\eqn{\frac{\Delta \sigma_L^{2}(l,\bm{x})}{\sum^l_{j=1}C_j} =
\frac{\int_{\Omega} \sigma_L^{*2}(\bm{\xi})-\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x}){\rm{d}}\bm{\xi}}{\sum^l_{j=1}C_j}},
where \eqn{f_L} is the highest-fidelity simulation code,
\eqn{\sigma_L^{*2}(\bm{\xi})} is the posterior variance of \eqn{f_L(\bm{\xi})},
\eqn{C_j} is the simulation cost at fidelity level \eqn{j},
and \eqn{\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})} is the posterior variance
based on the augmented design combining the current design and a new input location \eqn{\bm{x}}
at each fidelity level lower than or equal to \eqn{l}.
The integration is approximated by MC integration using uniform reference samples.
}
\details{
\code{Xref} plays a role of \eqn{\bm{\xi}} to approximate the integration.
To impute the posterior variance based on the augmented design \eqn{\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})},
MC approximation is used.
Due to the nested assumption, imputing \eqn{y^{[s]}_{n_s+1}} for each \eqn{1\leq s\leq l} by drawing samples
from the posterior distribution of \eqn{f_s(\bm{x}^{[s]}_{n_s+1})}
based on the current design allows to compute \eqn{\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})}.
Inverse of covariance matrix is computed by the Sherman-Morrison formula.
For details, see Heo and Sung (2023+, <arXiv:2309.11772>).

To search for the next acquisition \eqn{\bm{x^*}} by maximizing AL criterion,
the gradient-based optimization can be used by \code{optim=TRUE}.
Firstly, \eqn{\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})} is computed on the
\eqn{5 \times d} number of points.
After that, the point minimizing \eqn{\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})}
serves as a starting point of optimization by \code{L-BFGS-B} method.
Otherwise, when \code{optim=FALSE}, AL criterion is optimized only on \code{Xcand}.

The point is selected by maximizing the ALC criterion:
\eqn{\text{argmax}_{l\in\{1,\ldots,L\}; \bm{x} \in \Omega}
\frac{\Delta \sigma_L^{2}(l,\bm{x})}{\sum^l_{j=1}C_j}}.
}
\examples{
\dontrun{
library(lhs)
library(doParallel)
library(foreach)

### simulation costs ###
cost <- c(1, 3)

### 1-d Perdikaris function in Perdikaris, et al. (2017) ###
# low-fidelity function
f1 <- function(x) {
  sin(8 * pi * x)
}

# high-fidelity function
f2 <- function(x) {
  (x - sqrt(2)) * (sin(8 * pi * x))^2
}

### training data ###
n1 <- 13
n2 <- 8

### fix seed to reproduce the result ###
set.seed(1)

### generate initial nested design ###
X <- NestedX(c(n1, n2), 1)
X1 <- X[[1]]
X2 <- X[[2]]

### n1 and n2 might be changed from NestedX ###
### assign n1 and n2 again ###
n1 <- nrow(X1)
n2 <- nrow(X2)

y1 <- f1(X1)
y2 <- f2(X2)

### n=100 uniform test data ###
x <- seq(0, 1, length.out = 100)

### fit an RNAmf ###
fit.RNAmf <- RNAmf_two_level(X1, y1, X2, y2, kernel = "sqex")

### predict ###
predy <- predict(fit.RNAmf, x)$mu
predsig2 <- predict(fit.RNAmf, x)$sig2

### active learning with optim=TRUE ###
alc.RNAmf.optim <- ALC_RNAmf(
  Xref = x, Xcand = x, fit.RNAmf, cost = cost,
  optim = TRUE, parallel = TRUE, ncore = 10
)
alc.RNAmf.optim$time # computation time of optim=TRUE

### active learning with optim=FALSE ###
alc.RNAmf <- ALC_RNAmf(
  Xref = x, Xcand = x, fit.RNAmf, cost = cost,
  optim = FALSE, parallel = TRUE, ncore = 10
)
alc.RNAmf$time # computation time of optim=FALSE

### visualize ALC ###
par(mfrow = c(1, 2))
plot(x, alc.RNAmf$ALC$ALC1,
  type = "l", lty = 2,
  xlab = "x", ylab = "ALC criterion augmented at the low-fidelity level",
  ylim = c(min(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)),
           max(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)))
)
plot(x, alc.RNAmf$ALC$ALC2,
  type = "l", lty = 2,
  xlab = "x", ylab = "ALC criterion augmented at the high-fidelity level",
  ylim = c(min(c(alc.RNAmf$ALC$1, alc.RNAmf$ALC$2)),
           max(c(alc.RNAmf$ALC$1, alc.RNAmf$ALC$2)))
)
points(alc.RNAmf$chosen$Xnext,
  alc.RNAmf$ALC$2[which(x == drop(alc.RNAmf$chosen$Xnext))],
  pch = 16, cex = 1, col = "red"
)}

}
